{
  "hash": "037155fe86d2f2de3a9c3c268b050301",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Elections fun - 2025 edition\"\nauthor:\n  - name: Jens von Bergmann\n    affiliation: MountainMath\ndate: '2025-04-28'\nslug: elections-fun---2025-edition\ncategories:\n  - geeky\ntags: []\ndescription: \"Playing with Canadian 2025 federal elections data.\"\nimage: 'images/canada_election_2025_cartogram.png'\nbibliography: ../../common_literature.bib \ncode-tools:\n  toggle: true\nfig-width: 8\nexecute:\n  cache: true\n  message: false\n  warning: false\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n#remotes::install_github(\"mountainmath/mountainmathHelpers\")\nlibrary(mountainmathHelpers)\nlibrary(sf)\nlibrary(rmapshaper)\nlibrary(cancensus)\n\nmy_theme <- list(\n  labs(caption=\"MountainMath, Elections Canada\")\n)\n```\n:::\n\n\n\n\nFollowing our posts on the [2019 election](https://doodles.mountainmath.ca/blog/2019/10/22/elections-fun/) and [2021 election](https://doodles.mountainmath.ca/posts/2021-09-25-elections-fun-2021-edition/) we might as well re-use the code to run a high-level analysis of the 2025 federal election results. And also include the obligatory \"land does not vote - people do\" map pioneered by [Karim Douïeb](https://bsky.app/profile/karimdouieb.bsky.social). And thanks to [quarto](https://quarto.org) supporting [observable.js](https://observablehq.com/documentation/cells/observable-javascript) we can now embed the interactive maps directly into the post, as we did with the [2024 BC election results](https://doodles.mountainmath.ca/posts/2024-10-20-bc-election-2024/).\n\nInitially I was writing this on election day, with the goal of getting this up and then updating it regularly as the results come in. But the Elections Canada webpage stopped reporting results to the general public and it became too much of a pain. Ridings that have not been called by CBC are coloured in a lighter tone, those will disappear as the remaining ridings get called and the results are updated.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_cbc_data <- function() {\nlibrary(httr)\ncbc_url <- \"https://canopy.cbc.ca/live/elections/prov/FED2025/all/\"\n\n\ncbc_data<-content(GET(cbc_url))$data$ridings %>% \n  lapply(function(r){\n  ridings<-tibble(id=\"1\",ridingNumber=r$ridingNumber,name=r$englishName,totalVoters=r$totalVoters,totalPolls=r$totalPolls,\n         resultStatus=paste0(unlist(r$resultStatus),collapse=\", \"),\n         isCandidateElected=r$isCandidateElected,pollsReported=r$pollsReported,\n         totalVotesReported=r$totalVotesReported,candidateVotesLead=r$candidateVotesLead,\n         leadingPartyCode=r$leadingPartyCode)\n  parties <- r$parties %>% lapply(function(p){\n    tibble(id=\"1\",partyId=p$partyId,englishCode=p$englishCode,candidateFirstName=p$candidateFirstName,\n           candidateLastName=p$candidateLastName,votesPercentage=p$votesPercentage,votesLead=p$votesLead,\n           votes=p$votes,candidateId=p$candidateId)\n  }) |>\n    bind_rows()\n  full_join(ridings,parties,by=\"id\") %>% select(-id)\n}) |>\n  bind_rows() |>\n  mutate(called=isCandidateElected==1) |>\n  mutate(District=gsub(\"’\",\"'\",name) |> gsub(\"œ\",\"oe\",x=_))\n\n  cbc_data\n}\n\nget_electoral_areas <- function(refresh=FALSE){\n  simpleCache({\n    geos <-get_shapefile(\"https://ftp.maps.canada.ca/pub/elections_elections/Electoral-districts_Circonscription-electorale/federal_electoral_districts_boundaries_2023/FED_CA_2023_EN-SHP.zip\") %>%\n      rmapshaper::ms_simplify(0.1)\n    clip <- get_statcan_geographies(\"2021\",level=\"PR\") |>\n      st_transform(st_crs(geos)) |>\n      ms_simplify(0.05,sys=TRUE) |>\n      st_union() |>\n      st_make_valid() \n\n    geos |>\n      st_intersection(st_union(clip)) |>\n      st_collection_extract(\"POLYGON\") |>\n      st_make_valid() |>\n      rmapshaper::ms_simplify(0.5) |>\n      st_collection_extract(\"POLYGON\") |>\n      mutate(FEDUID=as.character(FED_NUM))\n    }, \"canada_electoral_district_geos_2023\",refresh = refresh) \n}\n\n\n\nget_election_results <- function(){\n  url=\"https://enr.elections.ca/DownloadResults.aspx\"\n  r <- httr::GET(url)\n  text_data <- httr::content(r,type=\"text\")\n  \n  rename_lookup <- c(\n    \"FEDUID\"=\"Electoral district number - Numéro de la circonscription\",\n    \"District\"=\"Electoral district name\",\n    \"Type\"=\"Type of results*\",\n    \"Surname\"=\"Surname - Nom de famille\",\n    \"Middle name(s)\"=\"Middle name(s) - Autre(s) prénom(s)\",\n    \"Given name\"=\"Given name - Prénom\",\n    \"Party\"=\"Political affiliation\",\n    \"Votes\"=\"Votes obtained - Votes obtenus\",\n    \"Votes_pct\"=\"% Votes obtained - Votes obtenus %\",\n    \"Rejected\"=\"Rejected ballots - Bulletins rejetés***\",\n    \"Total\"=\"Total number of ballots cast - Nombre total de votes déposés\"\n  )\n  read_tsv(text_data,skip=1,col_types = cols(.default=\"c\")) %>%\n    rename(!!!rename_lookup) %>%\n    select(names(rename_lookup)) %>%\n    filter(!is.na(FEDUID),!is.na(District)) %>%\n    mutate_at(c(\"Votes\",\"Votes_pct\",\"Rejected\",\"Total\"),as.numeric) %>%\n    mutate(Name=paste0(`Given name`,\" \",Surname)) %>%\n    mutate(Party=recode(Party,\"NDP-New Democratic Party\"=\"NDP\")) %>%\n    mutate(Party=coalesce(Party,\"Other\"))\n}\n\nparty_colours <- c(\n  \"People's Party\"=\"#4a3389\",\n  Conservative=\"#0C499C\",\n  \"Bloc Québécois\"=\"#02819E\",\n  Liberal=\"#A50B0B\",\n  NDP=\"#DA3D00\",\n  \"Green Party\"=\"#2E8724\",\n  \"Independent\"=\"#676767\",\n  #\"Undecided\"=\"#676767\",\n  Other=\"yellow\",\n  \"No results\"=\"#444444\"\n)\n\nprevious_results <- read_csv(\"https://www.elections.ca/res/rep/tra/2023rep/csv/Transposition_343_FED.csv\") |>\n  mutate(FEDUID=as.character(FED_NUM)) |>\n  select(FEDUID,District=FED_EN,Party=Political_Party_EN,Votes=Transposed_Votes,Votes_pct=Percent) |>\n  mutate(Party=gsub(\" Party of Canada\",\"\",Party) |> recode(\"New Democratic Party\"=\"NDP\",\"Green\"=\"Green Party\"))\n\n\nclean_parties <- function(data) {\n data %>%\n    mutate(Party=ifelse(Party %in% names(party_colours),Party,\"Other\")) %>%\n    mutate(Party=coalesce(Party,\"Other\")) %>%\n    mutate(Party=factor(Party,levels=names(party_colours)))\n}\n\ncleaned_previous_results <- previous_results |>\n  summarise(Votes=sum(Votes,na.rm=TRUE),\n            .by=c(\"FEDUID\",\"District\",\"Party\")) |>\n  mutate(Total=sum(Votes),.by=FEDUID) |>\n  mutate(Name=Party)\n\ngeos <- get_electoral_areas() %>%\n  st_transform(lambert_conformal_conic_at(.))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncbc_data <- simpleCache(get_cbc_data(),\"cbc_election_results_2025_04_29_16_45\")\n\nnot_called<- cbc_data%>% filter(!called) %>% pull(District)%>% unique\ncalled_districts<- cbc_data%>% filter(called) %>% pull(District)%>% unique\n\nnew_results <- get_election_results()  %>%\n  left_join((.) %>% filter(Type==\"validated\") %>% select(FEDUID) %>% unique %>% mutate(validated=TRUE),by=\"FEDUID\") %>%\n  mutate(validated=coalesce(validated,FALSE)) %>%\n  filter(Type==\"validated\" | (!validated & Type !=\"validated\")) %>%\n  mutate(Party=recode(Party,\"People's Party - PPC\"=\"People's Party\")) \n\n\nresults <- new_results |> \n  select(-Surname, `Middle name(s)`, `Given name`) |>\n  left_join(cleaned_previous_results |> \n              mutate(previous_winner=Votes==max(Votes,na.rm=TRUE),.by=FEDUID) |>\n              select(FEDUID,Party,previous_winner), \n            by=c(\"FEDUID\",\"Party\")) |>\n  mutate(dd=gsub(\"--\",\"-\",District)) |>\n  mutate(called=dd %in% called_districts)\n\nstopifnot(sum(sort(unique(results$dd))!=sort(unique(cbc_data$District)))==0) # make sure we don't miss any\n\n\n\ntmp <- tempfile(\"results_2025.csv\")\n#dd$called=sample(c(TRUE,FALSE), nrow(dd), TRUE)\nresults |>\n  mutate(Registered=Total) |>\n  mutate(Total=sum(Votes,na.rm=TRUE),.by=FEDUID) |>\n  filter(Party %in% names(party_colours)) |>\n  select(FEDUID,Candidate=Name,Party,Votes,called,previous_winner,validated,Type,Registered,Total) |>\n  write_csv(tmp)\ndummy <- file_to_s3_gzip(tmp,\"mountainmath\",\"elections/results_2025.csv\")\n```\n:::\n\n::: {.cell crop='true' clip='true'}\n\n```{.r .cell-code}\nmap_data <- geos |>\n  select(FEDUID) |>\n  left_join(results |>\n              clean_parties() |>\n              slice_max(n=1,order_by=Votes, with_ties = FALSE,by=FEDUID),by=\"FEDUID\") |>\n  mutate(Party=if_else(Total==0,\"No results\",Party))\n  #mutate(Party=factor(case_when(called~as.character(Party),\n  #                       TRUE~\"Undecided\"),levels=names(party_colours)))\n\nggplot(map_data,aes(fill=Party)) +\n  geom_sf(size=0.1) +\n  scale_fill_manual(values=party_colours) +\n  coord_sf(datum=NA) +\n  theme(legend.position = \"bottom\") +\n  labs(title=\"Canada federal election 2025\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=768}\n:::\n:::\n\n\n\nThis map makes it virtually impossible to get a good reading of the distribution of votes. There are a couple of ways around this. \n\nFor example, one could break out the areas with electoral districts too small to make a visible impact on the map, or use a cartogram, like shown on the [Wikipedia page of the 2021 federal election](https://en.wikipedia.org/wiki/2021_Canadian_federal_election).\n\nAnother way to structure a cartogram is to scale geographic regions to the size of their (voting) population, as can be seen in the following graph.\n\n\n\n::: {.cell crop='true'}\n\n```{.r .cell-code}\n# this takes forever\ncartogram_data <- simpleCache({\n  library(cartogram)\n  map_data |>\n    st_cast(\"POLYGON\") |>\n    mutate(a=st_area(geometry) |> as.numeric()) |>\n    mutate(area_rank=rank(a),\n           total_area=sum(a),.by=FEDUID) |>\n    mutate(pop=Total*a/total_area) |>\n    ms_simplify(keep=0.05) |>\n    cartogram_cont(weight=\"pop\",\n                   itermax = 150,\n                   maxSizeError = 1.1,\n                   prepare = \"adjust\",\n                   threshold = 0.2,\n                   verbose = TRUE)\n}, \"continuous_cartogram.rds\")\n\ncartogram_data |>\n  ggplot(aes(fill=Party)) +\n  geom_sf(size=0.1) +\n  scale_fill_manual(values=party_colours) +\n  coord_sf(datum=NA) +\n  theme(legend.position = \"bottom\") +\n  labs(title=\"Canada federal election 2025\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=768}\n:::\n:::\n\n\n\nWhile this fairly accurately represents the \"colour\" of the vote, most of the geographic references are lost and it is only of limited usefulness. Although interesting how Canada gets pinched at Hudson Bay with low population areas collapsed.\n\nAnother way to bridge the gap is to animate a map that moves between a cartographic view of Canada and a Dorling cartogram as popularized by [Karim Douïeb](https://bsky.app/profile/karimdouieb.bsky.social), as as we have done for past election. The following is a live animation morphing between the map and the cartogram, with tooltips providing added interactivity and details on ridings.\n\n\n\n\n\n```{ojs}\nvote_map_animation = {\n  const height = width*ratio ;\n  const svg = d3.select(DOM.svg(width, height))\n      .attr(\"viewBox\", \"0 0 960 600\")\n      .style(\"width\", \"100%\")\n      .style(\"height\", \"auto\");\n\n   debugger;\n  // render map\n  const path = d3.geoPath(projection);\n\n   svg.append(\"g\")\n     .selectAll(\"path\")\n     .data(districts)\n     .enter().append(\"path\")\n     .attr(\"class\", \"districtShape\")\n     .attr(\"fill\", d => d.properties.called ? party_colors[d.properties.winner.Party] : party_colors2[d.properties.winner.Party])  \n     .attr(\"d\", path)\n     .attr(\"stroke\", \"white\")\n     .attr(\"stroke-width\", 0.5)\n     .append(\"title\")\n     .text(tooltip) \n   \n  setInterval(() => {\n    svg.selectAll(\".districtShape\")\n      .transition()\n      .delay(d => 5 * d.properties.rank)\n      .duration(5000)\n      .attrTween('d', function(d, i) {\n        return flubber.toCircle(path(d), d.x, d.y, d.properties.radius, {maxSegmentLength: 2});\n      })\n\n    svg.selectAll(\".districtShape\")\n      .transition()\n      .delay(d => 10000 + 5 * d.properties.rank)\n      .duration(5000)\n      .attrTween('d', function(d, i) {\n        return flubber.fromCircle(d.x, d.y, d.properties.radius, path(d), {maxSegmentLength: 2});\n      })\n  }, 25000)\n\n  return svg.node();\n}\n```\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_data <- results %>%\n  clean_parties %>%\n  mutate(Share=Votes/Total) %>%\n  group_by(District) %>%\n  mutate(r=rank(Share)) %>%\n  mutate(LagShare=lag(Share,order_by = r)) %>%\n  top_n(1) %>%\n  mutate(margin=Share-LagShare)\n\nplurality <- plot_data %>% ungroup %>% filter(Share>0.5) %>% count\n```\n:::\n\n\n\nThis still loses a lot of nuance. The colour is determined by who won the district, the animation reveals no information on how wide or narrow the margin of victory was. Or how the other candidates performed. \n\n## Winning vote share\nWith more than 2 candidates in each riding, one does not necessarily require a plurality of votes to win. 224 out of the 343 candidates won with over 50% of the vote in their district, that's almost double of what we saw in the last election.\nThe largest vote share any winning candidate got was 84%, the lowest was 34%, both numbers up a little from what we saw in the last election. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(plot_data ,aes(x=reorder(District,Share),y=Share,fill=Party)) +\n  geom_bar(stat=\"identity\") +\n  coord_flip() +\n  scale_fill_manual(values=party_colours) +\n  my_theme +\n  scale_y_continuous(labels=scales::percent) +\n  theme(axis.text.y = element_blank()) +\n  labs(title=\"Canada 2025 federal election\",x=\"Voting districts\",y=\"Vote share of winning candidate\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=768}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_party <- plot_data %>% arrange(-Share) %>% head(1) %>% pull(Party) %>% as.character()\n\ntop_sweep <- plot_data %>% \n  ungroup %>%\n  arrange(-Share) %>% \n  mutate(n=row_number()) %>%\n  filter(Party != head(.,1)$Party) %>%\n  pull(n) %>%\n  min -1\n```\n:::\n\n\n\nIn the last election the top 4 spots in terms of vote share were taken by the Conservatives, this time around the Conservatives swept the top 23 spots.\n\n## Distribution of votes\nWe can expand this view to show the vote share by party for each district.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_data <- results %>% \n  clean_parties %>%\n  mutate(Share=Votes/Total) %>%\n  group_by(District) %>%\n  mutate(winner=Votes==max(Votes)) %>%\n  ungroup %>%\n  mutate(District=factor(District,levels=group_by(.,District) %>% \n                           filter(Party %in% c(\"People's Party\",\"Conservative\")) %>% \n                           summarize(Share=sum(Share,na.rm=TRUE),.groups=\"drop\") %>% \n                           arrange(Share) %>% \n                           pull(District),ordered = TRUE))\n\n\nggplot(all_data ,aes(x=District,y=Share,fill=fct_rev(Party))) +\n  geom_bar(stat=\"identity\") +\n  coord_flip() +\n  scale_fill_manual(values=party_colours) +\n  my_theme +\n  scale_y_continuous(labels=scales::percent) +\n  theme(axis.text.y = element_blank()) +\n  labs(title=\"Canada 2025 federal election\",x=\"Voting districts\",y=\"Vote share\",fill=\"Party\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=768}\n:::\n:::\n\n\n\n## Wasted votes\nWith our first-past-the-post system, we can also take a look at \"wasted\" votes. We define these as votes that have no bearing on the outcome. For winners it's the vote margin by which they won, for the ones that did not win their district it's the entirety of their votes. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwaste_data <- results %>% \n  clean_parties %>%\n  group_by(District) %>%\n  mutate(r=rank(-Votes)) %>%\n  left_join(filter(.,r==2) %>% select(District,required=Votes),by=\"District\") %>%\n  mutate(winner=Votes==max(Votes)) %>%\n  mutate(waste=ifelse(winner,Votes-required-1,Votes)) %>%\n  group_by(Party) %>%\n  summarize(waste=sum(waste),.groups=\"drop\")\n\n\nggplot(waste_data ,aes(x=Party,y=waste,fill=fct_rev(Party))) +\n  geom_bar(stat=\"identity\") +\n  #coord_flip() +\n  scale_fill_manual(values=party_colours,guide='none') +\n  my_theme +\n  scale_y_continuous(labels=scales::comma) +\n  labs(title=\"Canada 2025 federal election\",x=\"\",y=\"Wasted votes\",fill=\"Party\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=768}\n:::\n:::\n\n\n\nThe parties that got the most votes are naturally also the ones with the most votes to waste. \nWasted votes is a somewhat artificial system that does not necessarily reflect how parties would have performed under a different voting system. We will need to take a closer look for that.\n\n## First-past-the-post vs proportional representation\nHow would the parties have fared under a proportional representation system (PR) instead of first-past-the-post (FPTP)? There are many different kinds of proportional representation systems out there, but they generally try to approximate a seat distribution that mirrors the overall vote share. For simplicity we will simply take the overall vote share as a proxy for what a proportional representation system might have yielded. Well, kind of. The votes were cast under the expectation of a FPTP system, if we had switched to some kind of proportional representation or ranked ballot system some people would likely have voted differently and the outcome would have been different. We should view the PR alternative view as a first approximation to a PR outcome, if people were voting under a PR system the outcome could possibly be quite different.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npr_name_data <- cancensus::list_census_regions(\"CA16\") %>% filter(level==\"PR\") %>% arrange(as.integer(region))\npr_names <- set_names(pr_name_data$name,pr_name_data$region)\npr_share_data <- all_data %>% \n  mutate(PR=substr(FEDUID,1,2)) %>%\n  group_by(PR,Party) %>%\n  summarize(Votes=sum(Votes),Seats=sum(winner),.groups=\"drop\") %>%\n  group_by(PR) %>%\n  mutate(Share=Votes/sum(Votes)) %>%\n  mutate(Province=pr_names[PR] %>% as.character) %>%\n  #mutate(District=factor(District,levels=as.vector(pr_names))) %>%\n  mutate(Province=factor(Province,levels=group_by(.,Province) %>% \n                           filter(Party %in% c(\"People's Party\",\"Conservative\")) %>% \n                           summarize(Share=sum(Share,na.rm=TRUE),.groups=\"drop\") %>% \n                           arrange(Share) %>% \n                           pull(Province),ordered = TRUE)) %>%\n  ungroup %>%\n  select(-PR) %>%\n  rename(FPTP=Seats,PR=Votes) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npr_share_data %>%\n  group_by(Party) %>%\n  summarize(FPTP=sum(FPTP),PR=sum(PR),.groups=\"drop\") %>%\n  #mutate(PR=ifelse(PR/sum(PR)<0.05 | Party==\"Other\",0,PR))%>%\n  mutate(PR=PR/sum(PR)) %>%\n  gather(key=\"Voting system\",value=\"value\",c(\"FPTP\",\"PR\")) %>%\nggplot(aes(x=`Voting system`,y=value,fill=fct_rev(Party))) +\n  geom_bar(stat=\"identity\",position = \"fill\") +\n  coord_flip() +\n  scale_fill_manual(values=party_colours) +\n  my_theme +\n  scale_y_continuous(labels=scales::percent) +\n  theme(legend.position = \"bottom\") +\n  #theme(axis.text.y = element_blank()) +\n  labs(title=\"Canada 2025 federal election, comparing FPTP to PR with 5% minimum vote cutoff\",\n       subtitle=\"(preliminary results)\",\n       x=\"Voting system\",y=\"Share of seats\",fill=\"Party\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=768}\n:::\n:::\n\n\n\nLast time the Liberals were the big winner of FPTP, as was Bloc Québécois. This time around the NDP profited most from FPTP, at cost to the Liberals.^[Some people would likely change their voting behaviour if the voting system changed, this comparison makes the simplifying and somewhat unrealistic assumption that this won't happen and voting behaviour remains unchanged.] But overall, the election outcome would not have been that much different in who forms government under either system, but there is a difference in whether it's a minority or majority government.\n\n\nWe can run this by individual province to see how well each province is represented in terms of first-past-the-post vs proportional representation.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npr_share_data %>%\n  gather(key=\"Voting system\",value=\"Share\",c(\"FPTP\",\"PR\")) %>%\nggplot(aes(x=Province,y=Share,fill=fct_rev(Party))) +\n  geom_bar(stat=\"identity\",position = \"fill\") +\n  coord_flip() +\n  scale_fill_manual(values=party_colours) +\n  my_theme +\n  facet_wrap(\"`Voting system`\") +\n  scale_y_continuous(labels=scales::percent) +\n  theme(legend.position = \"bottom\") +\n  #theme(axis.text.y = element_blank()) +\n  labs(title=\"Canada 2025 federal election, comparing FPTP vs PR by province\",\n       x=\"Province\",y=\"Share of seats\",fill=\"Party\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/province_fptp_pr2-1.png){width=768}\n:::\n:::\n\n\n\n\n## Upshot\nThere is endless fun to be had with elections data. As usual, the code for this post, including the pre-processing for the animation, is [available on GitHub](https://github.com/mountainMath/doodles/blob/master/content/posts/2025-04-28-elections-fun---2025-edition/index.qmd) for anyone to adapt and dig deeper into elections data.\n\n\n<details>\n<summary>Remaining Observable code</summary>\n\n\n\n```{ojs}\napplySimulation = (nodes) => {\n  const simulation = d3.forceSimulation(nodes)\n    .force(\"cx\", d3.forceX().x(d => width / 2).strength(0.02))\n    .force(\"cy\", d3.forceY().y(d => width * (5/8) / 2).strength(0.02))\n    .force(\"x\", d3.forceX().x(d => d.properties.centroid ? d.properties.centroid[0] : 0).strength(0.3))\n    .force(\"y\", d3.forceY().y(d => d.properties.centroid ? d.properties.centroid[1] : 0).strength(0.3))\n    .force(\"charge\", d3.forceManyBody().strength(-1))\n    .force(\"collide\", d3.forceCollide().radius(d => d.properties.radius + nodePadding).strength(1.2))\n    .stop()\n\n  let i = 0; \n  while (simulation.alpha() > 0.01 && i < 200) {\n    simulation.tick(); \n    i++;\n    console.log(`${Math.round(100*i/200)}%`)\n  }\n\n  return simulation.nodes();\n}\n```\n\n```{ojs}\nspreadDistricts = applySimulation(districts)\n```\n\n```{ojs}\nmaxRadius = 10\n```\n\n```{ojs}\nradiusScale = {\n  const populationMax = districts.map(d => d.properties.Total).reduce((a, b) => Math.max(a, b), 0);\n  return d3.scaleSqrt()\n    .domain([0, populationMax])\n    .range([1, maxRadius]) \n}\n```\n\n```{ojs}\nratio = 0.8\n```\n\n```{ojs}\nnodePadding = 0.3\n```\n\n```{ojs}\ntooltip = f => {\n  const p = f.properties;\n  const w = p.winner;\n  return [\n        p.District,\n        `${p.called ? \"Winner\" : \"In the lead\"}: ${w.Candidate} - (${w.Party})`,\n  `${format.comma(p.Total)} votes counted`,\n          p.results.filter(d => d.Votes>0).map(d => {\n            return `${d.Party}:   ${format.comma(d.Votes)} (${format.percent(d.Votes/p.Total)})`\n          }).join(\"\\n\")\n        ].join(\"\\n\")\n}\n```\n\n```{ojs}\nparty_colors = {\n  return {\n    Liberal:\"#A50B0B\",\n    Conservative:\"#0C499C\",\n    \"Bloc Québécois\":\"#02819E\",\n    NDP:\"#DA3D00\",\n    Independent:\"#676767\",\n    \"Green Party\":\"#2E8724\",\n    \"Other\": \"#aaaa11\",\n    \"No results\":\"#808080\",\n  }\n}\n```\n\n```{ojs}\nparty_colors2 = {\n  return {\n    Liberal: \"#ce7474\",\n    Conservative: \"#83ACF5\",\n    \"Bloc Québécois\": \"#03aad0\",\n    NDP: \"#FFB38D\",\n    Independent: \"#FFCBB8\",\n    \"Green Party\": \"#84DA80\"\n  }\n}\n```\n\n```{ojs}\nformat = ({\n  density: (x) => x > 1000 ? d3.format(\".2s\")(x) : d3.format(\".3r\")(x),\n  percent: d3.format(\".1%\"),\n  comma: d3.format(\",.0f\")\n})\n```\n\n```{ojs}\nprojection =  d3.geoIdentity().reflectY(true).fitSize([960, 600], canada)\n```\n\n```{ojs}\ndistricts = canada.features.map(f => {\n  f.properties.centroid=projection([f.properties.X,f.properties.Y]);\n  return f;\n});\n```\n\n```{ojs}\ncanada = { \n  const url = \"https://s3.ca-central-1.amazonaws.com/mountainmath/elections/election_2025.json.gz\";\n  const canada = await d3.json(url);\n  const results = await d3.csv(\"https://mountainmath.s3.ca-central-1.amazonaws.com/elections/results_2025.csv\")\n  \n  const canada_results =  [...new Set(results.map(d => d.FEDUID))]\n    .reduce((hash, elem) => {\n      const rs = results.filter(r => r.FEDUID === elem)\n        .map(d=> {d.Votes=parseInt(d.Votes);\n                  d.Total=parseInt(d.Total);\n                  d.Registered=parseInt(d.Registered);\n                  return(d)})\n        .sort((a,b) => b.Votes-a.Votes)\n      hash[elem] = {results:rs,\n                    subTotal:d3.sum(rs, d => d.Votes),\n                    called:rs[0].called===\"TRUE\",\n                    winner:rs[0]}\n      return hash\n          }, {})\n  \n  const voteMax = d3.max(Object.keys(canada_results), d => canada_results[d].winner.Total)\n  const radiusScale = d3.scaleSqrt()\n      .domain([0, voteMax])\n      .range([1, maxRadius]) \n  \n  canada.features.forEach(d => {\n    const rp = canada_results[d.properties.FEDUID.toString()]\n      d.properties = {\n        ...d.properties,\n        ...rp,\n        x: d.properties.X,\n        y: d.properties.Y,\n        radius: d.properties.main ? radiusScale(rp.winner.Total) : 0\n      }\n  })\n\n  debugger;\n  \n  return canada; \n}\n```\n\n```{ojs}\nd3 = require(\"d3@5\")\n```\n\n```{ojs}\nturf = require(\"@turf/turf@5\")\n```\n\n```{ojs}\nflubber = require('https://unpkg.com/flubber')\n```\n\n\n\n</details>\n\n\n<details>\n\n<summary>Reproducibility receipt</summary>\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## datetime\nSys.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-04-30 07:27:26 PDT\"\n```\n\n\n:::\n\n```{.r .cell-code}\n## repository\ngit2r::repository()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLocal:    main /Users/jens/R/mountain_doodles\nRemote:   main @ origin (https://github.com/mountainMath/mountain_doodles.git)\nHead:     [9079e2e] 2025-04-30: make sure titles properly reflect that this is based on 2025 data, thanks kmavai!\n```\n\n\n:::\n\n```{.r .cell-code}\n## Session info\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.2 (2024-10-31)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sequoia 15.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/Vancouver\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] httr_1.4.7                cancensus_0.5.8          \n [3] rmapshaper_0.5.0          sf_1.0-20                \n [5] mountainmathHelpers_0.1.4 lubridate_1.9.4          \n [7] forcats_1.0.0             stringr_1.5.1            \n [9] dplyr_1.1.4               purrr_1.0.4              \n[11] readr_2.1.5               tidyr_1.3.1              \n[13] tibble_3.2.1              ggplot2_3.5.2            \n[15] tidyverse_2.0.0          \n\nloaded via a namespace (and not attached):\n [1] generics_0.1.3     class_7.3-22       KernSmooth_2.23-24 lattice_0.22-6    \n [5] stringi_1.8.7      hms_1.1.3          digest_0.6.37      magrittr_2.0.3    \n [9] evaluate_1.0.3     grid_4.4.2         timechange_0.3.0   fastmap_1.2.0     \n[13] jsonlite_2.0.0     e1071_1.7-16       DBI_1.2.3          scales_1.3.0      \n[17] codetools_0.2-20   cli_3.6.4          rlang_1.1.6        units_0.8-7       \n[21] munsell_0.5.1      withr_3.0.2        yaml_2.3.10        tools_4.4.2       \n[25] tzdb_0.5.0         colorspace_2.1-1   curl_6.2.2         vctrs_0.6.5       \n[29] R6_2.6.1           git2r_0.33.0       proxy_0.4-27       lifecycle_1.0.4   \n[33] classInt_0.4-11    V8_6.0.3           htmlwidgets_1.6.4  pkgconfig_2.0.3   \n[37] pillar_1.10.2      gtable_0.3.6       glue_1.8.0         Rcpp_1.0.14       \n[41] xfun_0.50          tidyselect_1.2.1   rstudioapi_0.17.1  knitr_1.48        \n[45] farver_2.1.2       htmltools_0.5.8.1  labeling_0.4.3     rmarkdown_2.28    \n[49] compiler_4.4.2     sp_2.1-4          \n```\n\n\n:::\n:::\n\n\n\n</details>",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}